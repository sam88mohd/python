- paradigm of storing all the configuration in vcs is known as infrastructure
as a code (IAC).

- since the configuration stored in files, those files can be stored in
vcs

- vcs gives us:
1. audit trail of changes
2. quickly rollback if a changes was wrong
3. lets other review our code to catch error and distribute knowledge
4. let us easily check out the state of our infrastructure by looking
at the rules that are commited.

- example of configuration management system:
1. puppet
2. chef
3. ansible
4 cfengine

puppet
------

- typicaly deploy puppet using a client-server architecture

- client: puppet agent
- server: puppet master

- agent connect to the master and sends bunch of facts that describe
the computer to the master

- master the proccess this info, generate the list of rules that need to be
applied to the device and send this list back to the agent

- agent is then in charge to making anu neccessary changes on the computer.

- puppet will determine the type of os being use and select the right tool
to perform the package installation.

- for linux, use apt, yum , dnf
- for mac - Apple Provider is used for packages are part of the os
            - MacPorts used package from MacPorts project
- for windows - need extra attributes, stating where is the installer located.

basic unit of puppet: resources - package, file, service 

class sudo {
    package { 'sudo':
        ensure => present,
    }
}

example of class
-----------------

class ntp {
    package { 'ntp':
        ensure => latest,
    }
    file {'/etc/ntp.conf':
        source => 'puppet://modules/ntp/ntp.conf'
        replace => true,
    }
    service { 'ntp':
        enable => true,
        ensure => running,
    }
}

* 3 resources
* grouped resources together in class
* example, class grouping all resources related to managing log files, configuring
time zone, handling temporary files and directories.

fact - a variables representing characteristic in puppet

if $facts['is_virtual] {
    package { 'smartmontools':
        ensure => purged,
    }
} else {
    package { 'smartmontools':
        ensure => installed,
    }
}

facts is a hash - same as dictionary in python - have key, value

descriptive code - that mean it will always result in success

exec { 'move example file':
    command => ' mv /home/user/example.txt /home/user/Desktop,
    onlyif => 'test -e /home/user/example/txt',
}

puppet is declarative language - it define the goal, not the step to achive the goal

add path - export PATH=/bin:/usr/bin

append path to environment variable $PATH - PATH=$PATH:/java/bin\n 

puppet dir:
cd /etc/puppet/code/environments/production/modules/profile/manifests

init.pp 

installing puppet locally:

1. sudo apt install puppet-master

2. create puppet file (manifest) - ends with .pp 

3. apply the manifest - sudo puppet apply -v <file.pp>

managing resource relationship:

class ntp {
    package {'ntp':
        ensure => latest,
    }

    file { '/etc/ntp.conf':
        source => '/home/user/ntp.conf',
        replace => true,
        require => Package['ntp'],
        notify => Service['ntp'],
    }

    service { 'ntp':
        enable => true,
        ensure => running,
        require => File['etc/ntp.conf'],
    }
}

include ntp # call the ntp class