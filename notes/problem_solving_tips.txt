#!/usr/bin/env python3
# -*- coding: utf-8 -*-
"""
Created on Tue Mar 21 21:01:58 2023

@author: sm
"""

PROBLEM SOLVING STEP
---------------------

1. gathering information
2. finding root cause
3. documentation
4. Long term remediation

strace <./ap.py> // trace application systemcall - systemcall is the command application call to the kernel

strace -o file.strace ./ap.py // store the stdout in a file
ltrace

less file.strace // shift-g to go to end of file

windows - proccess monitor // same as strace

where to find log:
    linux:
        var/log/syslog
        .xsession-errors
    mac:
        Library/Logs
    windows:
        Event Viewer
        
1.creating a reproduction case
2. finding root cause

test our hypotesis in test envionment - include set up new test server, test data and so on

iotop - use to check input output process.
iostat , vmstat - show statistic on the io operation
ionice - use to configure io resources
iftop - show current traffic process

rsync - backup software - us bwlimit to limit bw used
Trickle - set bw limit

nice - reduce priority of process using CPU

head -20 // print first 20 line

tail -5 // print last 5 line

wc -l <file>// print how many line for the file

expensive loop - avoid doing expensive operaton in a loop

resource:
 disk
 cpu
 io
 network

time of application accessing data depends on the data location.

if it is a variable use in a function, it will in cpu internal memory
if the data is related to a program but not in the current function running, it will in ram
if a data is a file, it will in hdd

cache: a form of storing the data for faster processing - cached in memory
web proxy is a cache: store website, images so it will not download everytime

possible way for slow:
1 not enough ram
2 to many open application
3 memory leak - memory which is no longer needed is not getting released

cProfile - count functions call

troubleshoot code:
use time <script> // calculate time to run the script
use pprofile3 -f callgrind -o profile.out <script> // store the output of the pprofile3
use kcachegrind profile.out // read the file generated

Threading / AsyncIO module

psutil

psutil.cpu_percent()
psutil.disk_io_counters()
psutil.net_io_counters()

multiprocessing module
from multiprocessing import Pool
pool = Pool()
pool.map(function, list)

CRASHING application

valgrind - powerful tool that can tell if the code doing any invalid operation - linux and mac
dr. memory - same as valgrind - for windows and linux

handling error:
1. use pdb in python3
2. printf debugging - technic of adding print to code to show the function of the code for debugging
3. logging moddule - enable and disable logging status

debugging segmentation fault:
1. create core file: ulimit -c unlimited
2. run the code again
3. ls -l core
4. gdb -c core <code filename>
5. use backtrace
6. up
7. list
8. print i
9. print argv[0], print argv[1]

debugging python:
1. pdb3 <python script>
2. use next to run line by line
3. use continue to run until error occured
4. print(row)

handling complex system:
- must have logging
- must have good monitoring system
- must use vcs

DEBUGGING MEMORY LEAK
1. use memory profiler - c,c++, use valgrind
2. for python - use memory_profiler

network saturation:
iftop

dealing with memory leak:

